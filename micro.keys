/*-----------------------------------------------------------------------------
 *  µMup07 = МикроМир07 = multi-platform text editor • macOS • Linux • Windows
 * ----------------------------------------------------------------------------
 * original "МикроМир" idea (c) А.Г.Кушниренко, Г.В.Лебедев (мехмат МГУ)   1981
 * "nanoMir" implementation (c) Attic (Д.В.Варсанофьев, А.Г.Дымченко) 1989-1991
 * "nanoMir" and МикроМир07 (c) EpiMG (М.Г.Эпиктетов)   1998-2001 and 2006-2022
-------------------------------------------------------------------------------
 Ins is "Help" key on MacPro keyboard, missing on A1243 (see KEY MAPPING below)
 Del is "Delete⌦" on Mac keyboard ("delete" key is Backspace)
 Return is either "Enter↵" or "Return" on main keyboard (not "enter" on numpad)
 PgUp/PgDown on MacBook keyboard may be entered as Fn+Up/Fn+Down (modifiers Ok)
 Super = user-defined extra modifier (default: right Ctrl, but see KEY MAPPING)
 Alt  == ⌥/option  key on Mac keyboard, Alt key elsewhere
 Meta == ⌘/command key on Mac keyboard, "WinKey" key on Windows-compatible one
                                (in all cases, Meta+{x} has alias without Meta)
COMMAND LINE
     PARAMETERS:    mim filename    - start editing given file
                    mim filename:N: - start editing given file at line N
(see also FILES     mim -           - start editing an empty text
   section below)   mim dirname     - open the contents of given directory
                    mim .           - start with current directory contents
Options:
 -dos  - save files in MS DOS format (with CR LF) instead of default POSIX (LF)
 -unix - force POSIX format (if no -dos/unix => mixed mode, use LF and show CR)
 -dq - debug memory allocation |
 -ti - show execution timing   | debugging only, not intended for regular use
 -kb - show keyboard commands  |
*/
k_BEGIN
/*
ʁFirst MicroMir principle:ʀ text is not a sequence of bytes (as it is represented
in the operating system) but rather a 2-dimensional matrix of lines filled with
characters, and has cursor (current editing position) located on some character

ʁBASIC CURSORʀ    {arrows}    - move cursor one position in given direction
  ʁMOVEMENTʀ      Ctrl+Left   - move cursor to beginning of the line
                Ctrl+Right  - move cursor to end of line (after last non-space)
       Alt+Up   / Alt+Down  - move cursor a few lines (1/6th of window) up/down
       Alt+Left / Alt+Right - move cursor word left/right
 ------------------------------------------------------------------------------
 Word = sequence of non-space characters; in addition, '(' starts new word, and
 comma and semicolon terminate the word (all three are included into the word)
*/
k_(LE_LEFT,       "Left",   0xd0012) /* курсор влево на одну позицию         */
k_(TE_UP,         "Up",     0xd0013) /* курсор вверх                         */
k_(LE_RIGHT,      "Right",  0xd0014) /* курсор вправо                        */
k_(TE_DOWN,       "Down",   0xd0015) /* курсор вниз                          */
k_(LE_BEG,   "Ctrl+Left",   0xd0412) /* курсор в самое начало строки         */
k_(LE_END,   "Ctrl+Right",  0xd0414) /* - в конец, за последний не-пробел    */
k_(TW_UP,     "Alt+Up",     0xd0813) /* на несколько строк вверх             */
k_(TW_DOWN,   "Alt+Down",   0xd0815) /* на несколько строк вниз (1/6ая окна) */
k_(LE_PWORD,  "Alt+Left",   0xd0812) /* -> предыдущее слово                  */
k_(LE_NWORD,  "Alt+Right",  0xd0814) /* -> следующее слово                   */
/*
     PgUp/PgDown    - scroll text one page (= windows height - 1) up/down
Ctrl+PgUp/PgDown    - move cursor to very beginning / end of the document
Ctrl+Up / Ctrl+Down - move continuously up/down (stop by any key)
Ctrl+[  / Ctrl+]    - move cursor to left / right edge of the current window
Ctrl+Shift+{arrows} - scroll text in given direction (cursor moves over text,
                      while remaining in the same position relative to window)
*/
k_(TE_PPAGE,         "PgUp",       0xd0016) /* на страницу вверх         ..0 */
k_(TE_NPAGE,         "PgDown",     0xd0017) /* на страницу вниз          ..1 */
k_(TE_TBEG,     "Ctrl+PgUp",       0xd0416) /* в самое начало текста         */
k_(TE_TEND,     "Ctrl+PgDown",     0xd0417) /* в самый конец текста          */
k_(TW_CUP,      "Ctrl+Up",         0xc0413) /* непрерывно вверх              */
k_(TW_CDOWN,    "Ctrl+Down",       0xc0415) /* непрерывно вниз               */
k_(LE_WLEFT,    "Ctrl+[",          0xd045b) /* в самую левую / правую        */
k_(LE_WRIGHT,   "Ctrl+]",          0xd045d) /*                  позицию окна */
k_(TW_SCROLUPN,     NULL,          0xd00fa) /* (mouse wheel                  */
k_(TW_SCROLDNN,     NULL,          0xd00fd) /*        scrolling)             */
k_(TW_SCROLLF,  "Ctrl+Shift+Left", 0xf1412)
k_(TW_SCROLUP,  "Ctrl+Shift+Up",   0xf1413) /* NOTE: scoll up/down   */
k_(TW_SCROLRG,  "Ctrl+Shift+Right",0xf1414) /*  differs in 2nd LSB:  */
k_(TW_SCROLDN,  "Ctrl+Shift+Down", 0xf1415) /*    ..1. up, ..0. down */
/*
For window handling, MicroMir uses concept familiar to UNIX programmers: 'fork'
(make a copy of the window) and 'replace file' (although this does not actually
replaces anything, it just pushes current text into stack like Esc <down> does)

  Meta+'+'('=') - open a new window with the same contents as in current one
  Meta+'-'      - split the window into two panes, forking the contents
  Meta+'\'(Del) - ask for filename and enter that file (see FILES below)
  Meta+']'      - open persistent scratch pad (saved in ~/.micro7.blah file)
  Meta+PgDown   - open deck of recently closed files (: ~/.micro7.deck file)
  (Esc,PgUp) - (closes window, saving all changes, see FILES commands below)
  Meta+{arrow}  - move cursor to closest window in given direction
  Meta+Return   - SyncPos + call MkSyncMarks (see auto.lua) to create markers
  Ctrl+X        - (tm)SyncPos - open file mentioned here (if not opend yet) in
      new window and move cursor to the mentioned line (for grep, compiler etc)

NOTE: commands in this section have alias Ctrl+Alt+X (except for Ctrl+Alt+Del)
*/
k_(TM_VFORK,   "Meta+=",      0xc103d) /* открыть новое окно с тем же самым  */
a_(TM_VFORK,   "Meta+Ins",    0xc103d) /*                         содержимым */
a_(TM_VFORK,   "Ctrl+Alt+=",  0xc103d)
a_(TM_VFORK,   "Ctrl+Alt+Ins",0xc103d)
k_(TM_HFORK,       "Meta+-",  0xc102d) /* поделить окно пополам      */
a_(TM_HFORK,   "Ctrl+Alt+-",  0xc102d) /*                            */
k_(TM_FENTR,   "Meta+Del",    0xf1007) /* ввести имя и войти         */
a_(TM_FENTR,   "Meta+\\",     0xf1007) /*           в указанный файл */
a_(TM_FENTR,   "Ctrl+Alt+\\", 0xf1007) /*                            */
k_(TM_F1ENTR,      NULL,      0xc10f1) /* в том же окне:      Return */
k_(TM_F2ENTR,      NULL,      0xc10f2) /* в новом окне: Shift+Return */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
k_(TM_LWINDOW,     "Meta+Left",   0xc1012) /* перейти к левому окну  */
k_(TM_UWINDOW,     "Meta+Up",     0xc1013) /* - к верхнему окну      */
k_(TM_RWINDOW,     "Meta+Right",  0xc1014) /* - к правому окну       */
k_(TM_DWINDOW,     "Meta+Down",   0xc1015) /* - к нижнему окну       */
k_(TM_GOBLAH,      "Meta+]",      0xf1008)
k_(TM_TODECK,      "Meta+[",      0xf100d)
a_(TM_TODECK,      "Meta+PgDown", 0xf100d)
a_(TM_TODECK,  "Ctrl+Alt+PgDown", 0xf100d)
a_(TM_GOBLAH,  "Ctrl+Alt+]",      0xf1008)
a_(TM_TODECK,  "Ctrl+Alt+[",      0xf100d)
k_(TM_SYNCPOX, "Ctrl+X",          0xc1005)
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
k_(TM_SYNCPOS,     "Meta+Return", 0xc1004) /* <- Синхронизировать позицию:   */
a_(TM_SYNCPOS, "Ctrl+Alt+Return", 0xc1004) /*        открыть в соседнем окне */
a_(TM_LWINDOW, "Ctrl+Alt+Left",   0xc1012) /*        упомянутый здесь файл и */
a_(TM_UWINDOW, "Ctrl+Alt+Up",     0xc1013) /*        перейти в указанную тут */
a_(TM_RWINDOW, "Ctrl+Alt+Right",  0xc1014) /*        строку -- работает для: */
a_(TM_DWINDOW, "Ctrl+Alt+Down",   0xc1015) /*     grep, (uni)diff, compilers */
/*
As a consequence of First Principle, Return & Tab keys do not insert any symbol
into text, but instead work as cursor movement commands (there are commands for
inserting TAB and CR into text and splitting lines at cursor, though):

  Tab / Shift+Tab  - move cursor to next / previous TAB position
  Alt+Shift+Tab    - insert TAB character into text
  Ctrl+Shift+1     - set marker 1 (red)   |
  Ctrl+Shift+2     - set marker 2 (green) | the markers are shown in the text
  Ctrl+Shift+3     - set marker 3 (blue)  | as colored "flag" with number and
  Ctrl+`(backtick) - go to auto marker    | as colored dots in "position bar"
  Ctrl+1           - go to marker 1 |
  Ctrl+2           - go to marker 2 | or set marker, if it does not exist yet
  Ctrl+3           - go to marker 3 |
  Ctrl+N           - go to next marker down in the text
  Ctrl+Shift+N     - go to previous marker up in the text
  Return           - move cursor to beginning of next line
  Shift+Return     - move cursor to next line, aligned with text in current one
  Alt+Shift+Return - insert CR character (only when in mixed end-of-line mode)

Note: for convenience, "go to marker" command sets the marker if not set yet,
and "set marker" works as toggle (and also clears all other marker from line)
*/
k_(LE_TAB,          "Tab",          0xd2001) /* в следующую |позицию       */
k_(LE_LTAB,   "Shift+Tab",          0xd2202) /* в предыдущую|   табуляции  */
a_(LE_LTAB,   "Shift+Backtab",      0xd2202) /*      (Backtab ≈ Shift+Tab) */
k_(LE_TABCHR, "Ctrl+Shift+Tab",     0xf2602) /*                            */
a_(LE_TABCHR, "Ctrl+Shift+Backtab", 0xf2602) /* вставить символ TAB ('\t') */
a_(LE_TABCHR,  "Alt+Shift+Backtab", 0xf2602) /* (Ctrl+Tab reserved on Mac) */
k_(LE_CRCHAR,  "Alt+Shift+Return",  0xf2613)
k_(TE_SMARK0, "Ctrl+Shift+`", 0xd2630) /* установить (или очистить)  */
k_(TE_SMARK1, "Ctrl+Shift+1", 0xd2631) /*  маркер 1 = красный флажок */
k_(TE_SMARK2, "Ctrl+Shift+2", 0xd2632) /*  маркер 2 = зеленый флажок */
k_(TE_SMARK3, "Ctrl+Shift+3", 0xd2633) /*  маркер 3 = синий флажок   */
a_(TE_SMARK0, "Ctrl+Shift+~", 0xd2630) /*                            */
a_(TE_SMARK1, "Ctrl+Shift+!", 0xd2631) /* (на macOS и Linux          */
a_(TE_SMARK2, "Ctrl+Shift+@", 0xd2632) /* shift+N уже преобразовано) */
a_(TE_SMARK3, "Ctrl+Shift+#", 0xd2633)
k_(TE_CMARK0, "Ctrl+`",       0xd2430) /* перейти к маркеру 0        */
k_(TE_CMARK1, "Ctrl+1",       0xd2431) /* -> 1                       */
k_(TE_CMARK2, "Ctrl+2",       0xd2432) /* -> 2      NOTE: codes must */
k_(TE_CMARK3, "Ctrl+3",       0xd2433) /* -> 3      be TE_S/CMARK0+N */
k_(TE_CMARKN, "Ctrl+N",       0xd243E) /* -> next                    */
k_(TE_CMARKP, "Ctrl+Shift+N", 0xd243F) /* -> previous                */
k_(TE_CR,           "Return", 0xc2004) /* в начало следующей строки  */
k_(TE_RCR,    "Shift+Return", 0xc2204) /* - - с выравниванием        */
/*
Typing either replaces text or insert characters before cursor position (moving
exising text right), depending on the current editing mode:

  Ctrl+Ins - set insert mode (text inserted before cursor, gradient cursor)
  Ctrl+Del - - replace mode (replaces existing text, indicated by solid cursor)
*/
k_(LE_CHAR,       NULL, 0xf3000) /* ввести обычный символ    */
k_(LE_RINS, "Ctrl+Ins", 0xf3406) /* установить режим вставки */
k_(LE_RREP, "Ctrl+Del", 0xf3407) /* установить режим замены  */
/*
Of course, any chages made to a text may be undone (and then re-applied) step-
by-step - that feature was introduced in early micromirs way before it become
common, so MicrMir07 still uses traditional key mapping (but also supports now
standard Ctrl/Command+Z alias):
                                            |
  Ctrl+Backsp == Ctrl/Meta+Z - undo changes | Ctrl+Shift+Backsp - "small" undo
  Ctrl+Return                - redo changes | Ctrl+Shift+Return - "small" redo
*/
k_(TE_UNDO,    "Ctrl+Backspace",       0xc3403) /* откатка последней         */
a_(TE_UNDO,    "Ctrl+Z",               0xc3403) /*       выполенной операции */
a_(TE_UNDO,    "Meta+Z",               0xc3403)
k_(TE_UNUNDO,  "Ctrl+Return",          0xc3404) /* "накатка" (работает если  */
k_(TE_SUNDO,   "Ctrl+Shift+Backspace", 0xc3603) /*      до этого откатились) */
k_(TE_SUNUNDO, "Ctrl+Shift+Return",    0xc3604) /* +Shift == мелкими шагами  */
/*
Although one can insert spaces into text by tapping space bar (in insert mode),
that's not how it is usually done in MicroMir, since there are special commands
for text modification:
                                                 |  +Shift (stronger)
  ------------+----------------------------------+--------------------------
  Ins         | insert empty character (space)   | insert empty line
  Del         | delete current character         | delete current line
  Backspace   | delete/clear char left of cursor | delete/clear word on left
  ------------+----------------------------------+--------------------------
  Ctrl+U     - delete/clear all characters up to cursor position
  Ctrl+D     - delete from cursor to end of line
  Ctrl+Q     - squeeze the word after cursor (and trailing spaces) from text
  Esc,Ctrl+U - delete everything from the beginning of file up to current line
  Esc,Ctrl+D - delete text from cursor to end of file (unless in the 1st line)
*/
k_(LE_IC,     "Ins",          0xf4006) /* вставить пробел на месте курсора   */
k_(LE_DC,     "Del",          0xf4007) /*    удалить символ под курсором     */
k_(TE_IL,     "Shift+Ins",       0xc4206) /* вставить пустую строку          */
k_(TE_DL,     "Shift+Del",       0xf4207) /* удалить текущую строку          */
k_(LE_BS,           "Backspace", 0xf4003) /* удалить/очистить символ слева   */
k_(LE_DLWORD, "Shift+Backspace", 0xf4203) /* удалить слово влево от курсора  */
k_(LE_DEOL,   "Ctrl+D",          0xf4444) /* - конец строки за курсором      */
k_(LE_DBGOL,  "Ctrl+U",          0xf4455) /* - начало строки до курсора      */
k_(LE_DWORD,  "Ctrl+Q",          0xf4451) /* - слово справа и пробелы за ним */
k_(TE_CLRBEG, "Esc,Ctrl+U",      0xc4c55) /* удалить текст за курсором       */
k_(TE_CLREND, "Esc,Ctrl+D",      0xc4c44) /* - до курсора      (много строк) */
/*
For those who are used to Return splitting text line - it can work that way,
if you press Home before Return (MicroMir uses Home & Esc keyes as prefixes,
both should be pressed and released before the next key, unlike Shift/Ctrl/…)

  Home,Return    - split the line, moving right part to beginning of new line
  Home,Backspace - join lines back, moving text as:    +------     +----------
                                                       |like█  <-> |like█this
  Home,Ins - split the line vertically                 |this       |
  Home,Del - join back:  +---------     +----------
                         |like█     <-> |like█that         (both join commands
                         |     that     |                   discard text right
  Alt+Shift+{arrows}                                        of cursor position)
    move selected text (from cursor to end of the line,
    if nothing selected) in given direction, overwriting whatever it moves over
*/
k_(TE_BLIN,     "Home,Return",     0xc5804) /* разрезать строку в начало    */
k_(TE_SLIN,     "Home,Ins",        0xc5806) /* разрезать строку вертикально */
k_(TE_NBLIN,    "Home,Backspace",  0xc5803) /* склеить строки               */
k_(TE_NSLIN,    "Home,Del",        0xc5807) /* склеить строки вертикально   */
k_(LE_MOVLEFT,  "Alt+Shift+Left",  0xf5312)
k_(TE_MOVUP,    "Alt+Shift+Up",    0xf5313) /* перетаскивание  */
k_(LE_MOVRIGHT, "Alt+Shift+Right", 0xf5314) /*  текста вместе  */
k_(TE_MOVDOWN,  "Alt+Shift+Down",  0xf5315) /*      с кусором  */
/*
Rudimental text formatting:

  Ctrl+T - center non-space text in current line using current window width
  F6 - do some formatting (depending of what pre-condition is applicable):

   * Split Very Long Lines (VLL): if the text in current line does not fit into
     window, then unfold it to several lines (splitting on word boundary unless
     that makes gap too big) adding continuation mark (sky blue '»') at the end

   * However, if current line already ends with continuation mark, do just the
     opposite - fold all consequent lines with that mark into single one; that
     line may be no fully editable, but should be Ok for saving it into a file
     (unless the length is more than current MicroMir limit of 4K per line)

   * If neither of above applies, try to join current line with the next one,
     provided the combined content fits into the window width
*/
k_(LE_CENTRX, "Ctrl+T", 0xc5454)
k_(TE_FORMAT, "F6",     0xf5035)
/*
More formatting implemented in Lua (auto-loaded at startup, see ":/auto.lua"):

  ^J,F6...F6,F6...  - mark left/right margins by block selection, then format
  Ctrl+F6,F6,F6...  - use previous margins                       line-by-line
  Shift+F6          - format all lines up to the next empty one

Format operation tries to fill the selected area with just enough text, splits
content past right edge into next line or grabs missing content from next line
(no hiphenation - breaks only at spaces, commas and semicolon, multiple spaces
are squeezed into one)

ʁSEARH AND REPLACE.ʀ MicroMir can search in text mode (case-sensitive or not), in
wildcard mode (? matches any symbol and * matches any substring), or in regular
expression one (see http://doc.qt.io/archives/qt-4.8/qregexp.html); the mode is
selected when entering search/replace pattern.

  Ctrl/Meta+F = Home End - edit search/replace pattern (start search by Return)
  Ctrl+Alt+F  = Meta+End - edit search pattern for 'grep' (searh though files)
        Ctrl+. (>)       - insert light blue 'ʈ>ʀ' (marks start of replacement)
        Ctrl+/           - insert light blue 'ʈ/ʀ' (start of filelist for 'grep')
        Ctrl+6 (^) - standard (text mode) search          ‹st·--›
        Ctrl+7 (&) - search by regular expression         ‹re·--›
        Ctrl+8 (*) - search with wildcards                ‹wc·--›
        Ctrl+I     - toggle case sensitivity: ignore case ‹--·ic› / not ‹--·cs›

  Ctrl+G       =       End - search (for previously entered pattern) forward
  Ctrl+Shift+G = Shift+End - search backward (up)
  Ctrl+B == Ctrl+      End - replace (if matches) or search down (if not)
            Ctrl+Shift+End - replace (if matches) or search up (if not)
*/
k_(TE_SENTR,        "Home,End", 0xf6811) /* ввод подстроки поиска и замены   */
a_(TE_SENTR,          "Meta+F", 0xf6811) /*    (Return или End - поиск вниз, */
a_(TE_SENTR,          "Ctrl+F", 0xf6811) /*            +Shift - поиск вверх) */
k_(LE_HCHAR0,         "Ctrl+,", 0xf642c) /*                                  */
k_(LE_HCHAR1,         "Ctrl+/", 0xf642f) /* начало списка файлов (для grep)  */
k_(LE_HCHAR2,         "Ctrl+.", 0xf642e) /* ('>') начало подстроки замены    */
k_(LA_STDMODE,        "Ctrl+6", 0xc6436) /*               | стандартный ‹st› */
k_(LA_REMODE,         "Ctrl+7", 0xc6437) /* Режим поиска: | regexp      ‹re› */
k_(LA_WCMODE,         "Ctrl+8", 0xc6438) /*               | wildcards   ‹wx› */
k_(LA_IGNOREC,        "Ctrl+I", 0xc6449)
k_(TE_SDOWN,          "Ctrl+G", 0xd6011)
a_(TE_SDOWN,             "End", 0xd6011) /* повторение поиска вниз */
k_(TE_SUP,         "Shift+End", 0xd6211) /* повторить поиск вверх  */
a_(TE_SUP,    "Ctrl+Shift+G",   0xd6211)
k_(TE_RUP,    "Ctrl+Shift+End", 0xc6611) /* замена/поиск вверх */
k_(TE_RDOWN,  "Ctrl+End",       0xc6411) /* замена/поиск вниз  */
a_(TE_RDOWN,  "Ctrl+B",         0xc6411)
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
k_(TE_GENTR,  "Ctrl+Alt+F",     0xf6511) /* глобальный поиск (grep, по всем  */
a_(TE_GENTR,  "Ctrl+Alt+End",   0xf6511) /*                файлам из списка) */
a_(TE_GENTR,      "Meta+End",   0xf6511) /* искать                           */
k_(TM_GREP,             NULL,   0xf65f1) /*   в том же окне:          Return */
k_(TM_GREP2,            NULL,   0xf65f2) /*   в новом окне:     Shift+Return */
/*
ʁSecond MicroMir principle:ʀ text is moved around using copy / paste buffer, with
basic operations being "add something to the buffer" and "paste the buffer into
text". Once the buffer is used, it can be pasted again, but the very next "add"
command will clear it, starting saving anew. Older micromir clones used to have
at least two separate buffers (for character and lines), which made intergation
with system clipboard problematic, but MicroMir07 has only 1, kept in sync with
clipboard by some magic that mostly works (if it does not, manual sync commands
are provided for your convenience):

        F1 - add ("save") current character (or selection) to copy/paste buffer
  Shift+F1 - save character (selection) and then delete it from the text
        F2 - add ("save") word under cursor to copy/paste buffer
  Shift+F2 - save word and delete it
        F3 - add ("save") current line to copy/paste buffer
  Shift+F3 - save line and delete it
   Home,F3 - save a line with current position (full filename, line number)
        F4 - paste the buffer content into text (does not clear the buffer)
Note
  Multi-line text in c/p-buffer inserted depending on where it came from: block
  selection pasted alighed over existing text, for clipboard contents new empty
  line is inserted on each CR/LF (and text starts at left margin)
*/
k_(LE_CCHAR,        "F1", 0xf7030) /* добавить символ в буфер ("запомнить") */
k_(LE_CDCHAR, "Shift+F1", 0xf7230) /* запомнить символ с удалением          */
k_(LE_CWORD,        "F2", 0xc7031) /* запомнить текущее слово               */
k_(LE_CDWORD, "Shift+F2", 0xc7231) /* - - текущее слово с удалением         */
k_(TE_CLIN,         "F3", 0xc7032) /* добавить строку в буфер ("запомнить") */
k_(TE_CDLIN,  "Shift+F3", 0xc7232) /* - - запомнить строку с удалением      */
k_(TE_CLPOS,   "Home,F3", 0xc7832) /* - - запомнить файл/позицию как строку */
k_(LE_PASTE,        "F4", 0xf7033) /* вспомнить все запомненное             */
/*
  Ctrl/Meta+C - save selection (if any), and force copy to system clipboard
  Ctrl/Meta+V - paste from system clipboard
     Shift+F4 - mark the buffer as "used" (next save will clear it)
      Ctrl+F1 - "re-open" copy/paste buffer (remove "used" mark)
*/
k_(TE_TOCLIP,   "Ctrl+C", 0xf7443)
a_(TE_TOCLIP,   "Meta+C", 0xf7443)
k_(TE_FROMCB,   "Ctrl+V", 0xc7456)
a_(TE_FROMCB,   "Meta+V", 0xc7456)
k_(LE_CPCLOS, "Shift+F4", 0xf7233) /* начнем запоминать по новой */
k_(LE_CPOPEN,  "Ctrl+F1", 0xf7430) /* наоборот, будем добавлять  */
/*
ʁSELECTION.ʀ Although text can be copied without selecting anything, MicroMir has
mechanism of rectangular selections: Shift+{arrows} makes "temporary" selection
(grey rectangle),  F5 followed by any regular cursor movement makes "permanent"
selection (light blue rectangle). -- Typing DO NOT overwrites selected text --

  Shift+{arrows}                           - start/extend "temporary" selection
  F5 ..(any movement except for Return)..  - start/extend "permanent" selection
  Ctrl+W  - select current word (or word left of cursor, if cursor not on word)
*/
a_(LE_LEFT,    "Shift+Left",   0xe0012) /* влево       |             */
a_(TE_UP,      "Shift+Up",     0xe0013) /* вверх       | с отметкой  */
a_(LE_RIGHT,   "Shift+Right",  0xe0014) /* вправо      |     блоком  */
a_(TE_DOWN,    "Shift+Down",   0xe0015) /* вниз        |             */
k_(LE_MWORD,   "Ctrl+W",       0xc8057) /* выделить текущее слово    */
k_(TX_MCBLOCK,     "F5",       0xc8034) /* == "постоянный" блок      */
/*
When selection (of either type) is active, some commands operate with selected
text instead of current character, namely:

        F1 (Ctrl/Meta+C) - add selected text to copy/paste buffer
  Shift+F1               - save selection and delete from text
  Shift+Del              - clear the text covered by selection rectangle
  Shift+Backspace        - remove the selected area from text (collapse)

If the selection is one character wide, then most line editing commands work on
all lines affected, for example:

  Ins             - insert column of spaces at the selection
  Del             - delete column at the selection
  {any character} - insert character at the block position in all lines

The following commands also can work with selections, but only with single-line
ones (without selection, current character is converted and cursor moves right)

  Ctrl+Shift+6(^) - convert current character (or selected block) to uppercase
  Ctrl+Shift+-(_) - convert current character (or selected block) to lowercase
  Ctrl+Shift+B    - add / clear "bold" attribute

NOTE: "bold" attribute is marked by Unicode chars U+281 / U+280 (which are very
unlikely to appear in regular text) and not compatible with anything.. not even
with build-in MicroMir search engine. Use at your own risk, you've been warned!
*/
k_(LE_CCUP,  "Ctrl+Shift+6", 0xf8913) /* буква -> прописная           */
k_(LE_CCDWN, "Ctrl+Shift+-", 0xf8915) /* буква -> строчная            */
a_(LE_CCUP,  "Ctrl+Shift+^", 0xf8913) /*   (only works in 'C' locale) */
a_(LE_CCDWN, "Ctrl+Shift+_", 0xf8915) /*                              */
k_(LE_CBOLD, "Ctrl+Shift+B", 0xf8442) /* сделать жирным               */
/*
ʁThird MicroMir principle:ʀ instead of relying on sorting capabilites provided by
file browser, one can keep files sorted his/her way (and also add any comments)
by listing filenames in 'micros.dir'.  This is a regular text file, except that
it has '|' symbols in all lines in 64th position (and, optionally, in 69th one)

  Esc,Right   - move right to the filename field (return back by Return)
  Esc,Down    - down into file (filename taken from the text, see below)
  Esc,Up      - up one level = normal exit (with changes automatically saved)
  Esc,PgUp    - up all levels (closing the window), with changes saved
  Esc,Ctrl+A  - abandon all changes and leave the file (up one level)
  Ctrl/Meta+R - reload the file (or directory contents) from disk
  Ctrl/Meta+S - save all changes without leaving the file
*/
k_(TM_INFILE, "Esc,Right",  0xc9414) /* перейти к имени файла */
k_(TM_FNEW,   "Esc,Down",   0xf9415) /* войти в новый файл    */
k_(TM_EXIT,   "Esc,Up",     0xc9413) /* выйти с сохранением   */
k_(TM_QUIT,   "Esc,PgUp",   0xc9416) /* выйти совсем          */
k_(TM_EXOLD,  "Esc,Ctrl+A", 0xc9c41) /* выйти без сохранения  */
k_(TM_RELOAD, "Meta+R",     0xc9452)
a_(TM_RELOAD, "Ctrl+R",     0xc9452) /* перезагрузить файл    */
k_(TM_UPDATE, "Meta+S",     0xc9453) /* сохранить изменения   */
a_(TM_UPDATE, "Ctrl+S",     0xc9453)
/*
  This "down into file" command works not only in 'micros.dir', but also in any
text that has name of other file included - just move cursor to that name, then
press Esc <down> (the name should be separated from surrounding text by spaces,
commas or quotes - if is't not, you'll need to use block selection to mark it)

 In that case MicroMir searches for the file in stadard locations for includes
 (/usr/local/include, /usr/include on Linux and macOS) and in places specified
 by 'incdris' lines at the bottom on 'micros.dir' - those lines are iserted by
 by Shift+Ins (with protected prefix) while at the very bottom of the file and
 may have optional platform restriction, for example:

  ʂincdirs»ʀ(unix)/usr/include/lua5.2 -- search in this directory on Linux only
  ʂincdirs»ʀ(win32)../lua/include     -- search there only on Windows
  ʂincdirs»ʀinclude,../include        -- search both folders on all platforms

Special ʁFILESʀ (content obtained by running some command, discarded afterward):

  filename:git:rev == filename::rev - file revision from given git commit
  filename:gitlog[options]          - list of revisions, from 'git log'
  filename:blame[options]           - results of 'git blame' for given file
  filename:hg:rev                   - file revision (-r) from Mercurial commit
  filename:hglog[options]           - list of revisions, from 'hg log'
  filename:annotate[options]        - results of 'hg annotate' for given file
  «shell-command»                   - the result of specific shell command
  (double angle quotations mark can be entered by Alt+'\' and Alt+Shift+'\';
   when starting MicroMir in command prompt, these marks may be replaced with
   single quote before the parameter: ʈ>ʀ mim \''git log' -- will open git log)

MicroMir automatically detects read-only files and don't allow changing them...
unless you insist: edit/view mode may be changed at any time (at your own risk)

  Ctrl+Shift+Ins - set text edit mode (green or blue cursor, can change text)
  Ctrl+Shift+Del - set text view mode (no changes allowed, red cursor)
*/
k_(TE_SRW, "Ctrl+Shift+Ins", 0xca506) /* установить режим редактирования   */
k_(TE_SRO, "Ctrl+Shift+Del", 0xca507) /* установить режим просмотра текста */
/*
ʁREPETITION:ʀ Esc,N - enter repetition counter (or argument) for the next command
                              where N is either ddd decimal number like   126
                                               0ddd octal number such as 0176
For example:                                   xddd hexadecimal number    x7e
                                               or 'i' -> 2147483647 (infinity)
  Esc,3,Shift+Del - delete 3 lines
  Esc,5,*         - same as typing ***** (insert/replace depending on the mode)
  Esc,N,Alt+Ins      - insert character with given Unicode number
  Esc,N,Ctrl+Shift+9 - convert word/selection from radix-N (hex) to decimal
  Esc,N,Ctrl+Shift+0 - convert word/selection to radix-N (where N = 2..36)
  Esc,N,Ctrl+Shift+] - set the width (of editable part) of the text
  Esc,N,Ctrl+E       - move cursor to Nth line in text
  Esc,N,Ctrl+H       - move cursor to Nth position in current line

NOTE: without repetition prefix, the last two commands work differently, which
    is a special convenience feature to allow easy centering specific position:

  Ctrl+E - centers current line in the windows (vertically only)
  Ctrl+H - centers curret position in the windows (horizontally)

Note for Windows 7: keyboard shortcut Ctrl+Shift+0 does not work with default
   configuration. Refer to http://support.microsoft.com/kb/967893 for the fix.
*/
k_(TK_PREFIX, "Home",         0xcc00a) /* Home (generic) префикс          */
k_(TK_ESC,    "Esc",          0xcc00e) /* Esc префикс (повторитель и пр.) */
k_(TK_CtrJ,   "Ctrl+J",       0xcc010) /* ^J префикс (используется в Lua) */
k_(LE_SPCHAR, "Alt+Ins",      0xfb606) /* ввести символ по Unicode коду   */
k_(LE_CWDEC,  "Ctrl+Shift+9", 0xfb92c) /* перевести число в десятичное    */
k_(LE_CWHEX,  "Ctrl+Shift+0", 0xfb92e) /* - в 16-ричное / основание N     */
a_(LE_CWDEC,  "Ctrl+Shift+(", 0xfb92c) /*     (на MacOS Х и Linux shift+N */
a_(LE_CWHEX,  "Ctrl+Shift+)", 0xfb92e) /*              уже преобразовано) */
k_(TE_SWIDTH, "Ctrl+Shift+]", 0xcb65d) /* установить ширину текста        */
a_(TE_SWIDTH, "Ctrl+Shift+}", 0xcb65d) /*                                 */
k_(TE_CENTR,  "Ctrl+E",       0xfb445) /* в середину окна по вертикали    */
k_(LE_CENTR,  "Ctrl+H",       0xfb448) /*               - по горизонтали  */
/*
ʁLua SCRIPTING:ʀ MicroMir embeds Lua scripting language (see http://www.lua.org),
scripts are supposed to be opened just as regular texts and then executed using
these commands (plus ":/auto.lua" automatically loaded/executed at startup):

    Ctrl+J,Ctrl+J - load and executes the entire current text as Lua script
    Ctrl+Shift+J  - load/execute current line as (single-line) Lua script
    Ctrl+J,A      - enter local auto-load executable script (~/.micro7.ales)
    Ctrl+J,N      - create new unnamed/throw-away text for new Lua script
*/
k_(TM_LUAF,    "^J,Ctrl+J", 0xfc000) /* загрузить и выполнить программу на   */
k_(TM_LUAS, "Ctrl+Shift+J", 0xfcc00) /*  языке Lua из текущего текста/строки */
k_(TM_LUAA, "^J,A",         0xfc00a)
k_(TM_LDBG, "^J,D",         0xfc00d)
k_(TM_LUAN, "^J,N",         0xfc00e) /* ? likely to be removed in the future */
/*
MicroMir-specific Lua objects and operations

  Mk["keysequence"] = Mk["other-sequence"] -- remap existing MicroMir command
  Mk["keysequence"] = "text-and-commands"  -- map text with embedded commands…
  Mk["keysequence"] = function(Tx,count)   -- map Lua function to key sequence
    ...
  end
  Mk:Do( Mk["keysequence"] ) -- execute given command (or text with commands),
  Mk:Do("text-and-commands") --      as if they were entered from the keyboard

  Tx = Txt.open("filename") -- create/open given file in new window
  Tx = Txt.open(true)       -- open new window with unnamed file (saveable)
  Tx = Txt.open(false)      -- open new window with throw-away text
  Tx = Txt.this             -- reference to "this" text (may be used only from
                                    text with script iself, not from functions)
  Tx.id -- text ID = index in Txt
  (should be used for safe reference, Txt[Tx.id] -> Tx or nil if text replaced)

  Tx:focus() -- focus last opened window, associated with the text
  Tx:line(N) -- content of Nth line in given text (= nil if past end-of-text)
  Tx:lines() -- iterator over the text:  for N,line in Tx:lines() do ... end
  Tx.X, Tx.Y -- current cursor position (assigning new value will move cursor)
  Tx.reX,reY -- another corner of the selection rectangle (nil if no selection)
  Tx.maxY    -- max value of Y in text  (= total number of lines in given text)
  Tx:go(dy)
  Tx:go(dx,dy) = convenience methods to move cursor around (because Lua does
                                           not allow 'Tx.Y++' or 'Tx.Y += k')
NOTE:
  attempt to move cursor out of text boundaries does not generate any error,
  cursor just moves as far as possible in requested direction

  Tx:IC("text") -- insert text into current line | moves cursor past
  Tx:IL("line") -- insert given line at cursor   |     inserted text

  Tx:mark(k,x,y,"text") -- add/update mark k (0…19) at given position (use x=0
  Tx:DC(N) -- delete N characters at cursor                     to remove mark)
  Tx:DL(N) -- delete N lines at cursor (default = 1)
  Tx:gtl() -- get-text-left convenience method = gets first chunk of non-spaces
                                       from text to the left of cursor position
[line 561] xref: new.lua

  re = Re("..regex..",true/false) -- regular expression (arg: case sensitivity,
  re = Re[[..regex..]]                                default = case-sensitive)
  re:ifind("str"[,pos]) -- returns index of first match (nil if does not match)
  re:cap(N)             -- returns Nth capture (only when called after 'ifind')
  re:caps()             -- all captures (to use in multi-value assignement)
  re:grepl("str","to")  -- globally replace pattern (where \N = Nth capture)

Examples (auto-loaded at startup):

  Mk["Ctrl+Shift+T"] = function(Tx) Tx:IC(os.date()) end
  Mk["Ctrl+Shift++"] = function(Tx)
    local result = loadstring("local X="..Tx:gtl()..";return X")()
    Tx:IC("= "..tostring(result))
  end
  for _,n in pairs{"F7","F8","F9"} do -- inserts current value of Fn macro into
    Mk["^J,"..n] = function(Tx)       --  current text (to edit and re-execute)
      local pref,Fn = "Mk."..n.."=",Mk[n]
      if type(Fn) == 'string' then Tx:IL(pref..'"'..Fn..'"')
                              else Tx:IL(pref..'none') end
    end
  end
  Mk2html(Txt.this) -- convert this text to HTML (use Ctrl+Shift+J here)
*/
k_(TK_SM0,       NULL, 0xfd235) /* ʁMACRO:ʀ In addition to universal scripts, */
k_(TK_SM1, "Shift+F7", 0xfd236) /* MikroMir provides quick method to record */
k_(TK_SM2, "Shift+F8", 0xfd237) /* simple sequence of action & play it back */
k_(TK_SM3, "Shift+F9", 0xfd238) /* later by just one keypress:              */
k_(TK_EM0,       NULL, 0xfd035) /*                                          */
k_(TK_EM1, "F7",       0xfd036) /*   Shift+F7/F8/F9 - start recording macro */
k_(TK_EM2, "F8",       0xfd037) /*         F7/F8/F9 - finish recording, or  */
k_(TK_EM3, "F9",       0xfd038) /*       execute previously recorded macro  */
/*
ʁSYNTAX CHECKER:ʀ  MicroMir performs minimal syntax check (mostly bracket balance
and proper quoting) and highlights keywords and comments, depending on language
used in the text (which is determined by file extension and/or #! in 1st line).
 Currently works more or less reliable for C/C++ formatted with "proper" style,
so a couple of commands added to turn it on/off dynamically (on per-file basis)

  Ctrl+Shift+8/'*'  - disable syntax check / coloring for given file
  Ctrl+Shift+7/'&'  - (re-)enable syntax check
  Ctrl+O (letter O) - toggle "show all brackets not closed in the line" mode
  (sequence Esc,0,Ctrl+O turns off bracket position check, reducing warnings)
*/
k_(TE_BRAKON,  "Ctrl+Shift+7", 0xce639) /* включить раскраску  */
a_(TE_BRAKON,  "Ctrl+Shift+&", 0xce639)
k_(TE_BRAKOFF, "Ctrl+Shift+8", 0xce630) /* выключить раскраску */
a_(TE_BRAKOFF, "Ctrl+Shift+*", 0xce630)
k_(TE_SHBRAK,  "Ctrl+O",       0xce44f) /* переключить режим   */
/*
ʁMISCELLANEOUS.

  Ctrl+A - abandon (cancel) current command (e.g. stop entering search pattern)
  Ctrl+K - display unicode value of the current character in the info window
  Ctrl+L - display line number / block size / backet balance (default)
  Ctrl+P - display cursor position in text (character and line numbers)
  Ctrl+Y - (sYstem) = ask for shell command and execute it
   in shell command:
        light blue 'ʈ•ʀ' (Ctrl+'<') is replaced with the name of current file,
        light blue 'ʈ/ʀ' (Ctrl+'/') replaced with full path to current file
*/
k_(TK_NONE,   NULL,     0xce000) /* None command */
k_(TK_BREAK,  "Ctrl+A", 0xce441)
k_(TK_CHARK,  "Ctrl+K", 0xce44b)
k_(TK_LINFO,  "Ctrl+L", 0xce44c)
k_(TK_PINFO,  "Ctrl+P", 0xce44d)
k_(TM_SHELL,  "Ctrl+Y", 0xfe459) /* ввести и выполнить команду shell         */
k_(TM_FEXEC,  NULL,     0xceef1) /* в том же окне:                    Return */
k_(TM_F2EXEC, NULL,     0xceef2) /* в новом окне:               Shift+Return */
/*
ʁGRADIENTS:ʀ By default MicroMir07 fills background with linear gradient (because
solid background is just too boring), which may be configured using Preferences
dialog. Full format of gradient specification is the following (square brackets
mark optional parts):

  primColor[/offColor][,grad:start[-stop]][,2nd:prim2][,3rd:prim3][,4th:prim4]

where primColor - primary gradient color for first (default) color palette
       offColor - off-color (default "white")
     start/stop - start/stop points from 0 (top left) to 1.0 (bottom right)
          primN - primary color for Nth color palette
Color:
  #rrggbb 24-bit hexadecimal RGB value                for example:    #ffefd5
  SVG color names (see http://www.w3.org/TR/SVG11/types.html)      papayawhip
  Hue degrees  (in that case Sat=16% and Val=100% are forced)      40° or 40*

  Ctrl+Alt+1 - switch to first / default palette in current window
  Ctrl+Alt+2 - switch to palette 2 (if not confiured, using 80° light green)
  Ctrl+Alt+3 - switch to palette 3 (default is 200° sky blue)
  Ctrl+Alt+4 - switch to palette 4 (default is "mistyrose")
*/
k_(TW_GRAD1, "Ctrl+Alt+1", 0xcfc31) /* включить палитру 1 в текущем окне */
k_(TW_GRAD2, "Ctrl+Alt+2", 0xcfc32) /* - палитру 2 (зеленая)             */
k_(TW_GRAD3, "Ctrl+Alt+3", 0xcfc33) /* - палитру 3 (голубая)             */
k_(TW_GRAD4, "Ctrl+Alt+4", 0xcfc34) /* - палитру 4 (розовая)             */
/*
ʁKEY MAPPINGʀ. In order to accommodate different keyboards, MicroMir provides key
aliases that may be specified in the Preferences dialog as comma-separated list
of "alias=key" pairs. Syntax for both elements is consistent with this document
(if you are not sure what is the name of particular key,  try starting MicroMir
with '-kb' option, the names of keys will be displayed in the Info window), and
the alias automatically works with any modifier. For example, if keyboard lacks
Ins/Del keys (but have extra function or numpad keys), then you can use these:

  F11=Ins,F12=Del   -- use F11 as alias for Ins and F12 as alias for Del
  [0]=Ins,[.]=Del   -- use numpad keys for Ins and Del

This key mapping field may also define Super modifier in terms of native flags,
using "Super=0x{hex}" format (for example, Super=0x2100 for right Ctrl on Mac);
currently it is not possible to combine this modifier with others

  Mac: 0x0104 right Shift,          Win: 0x010 right Shift, ( 0x100 CapsLock )
       0x0110 right Meta(⌘/win),         0x020 right Ctrl,  ( 0x200 NumLock  )
       0x0140 right Alt (⌥/opt),         0x040 right Alt,   ( 0x400 ScrLock  )
       0x2100 right Control              0x080 right WinKey

See "Lua SCRIPTING" for remapping MicroMir commands to different key sequences.
-------------------------------------------------------------------------------
Some useful Alt+CHAR (most are present on Mac already, but a few of them moved)
*/
a_(0, "Alt+1", 0x00B9) /* ¹ */    a_(0, "Alt+Shift+!", 0x00A1) /* ¡         */
a_(0, "Alt+2", 0x00B2) /* ² */    a_(0, "Alt+Shift+:", 0x205D) /* ⁝ (moved) */
a_(0, "Alt+3", 0x00B3) /* ³ */    a_(0, "Alt+=",       0x2248) /* ≈         */
a_(0, "Alt+D", 0x2023) /* ‣ */
a_(0, "Alt+W", 0x201E) /* „ */
a_(0, "Alt+X", 0x00D7) /* × */
a_(0, "Alt+Shift+W", 0x2191)   a_(0, "Alt+Shift+A", 0x2190) /*    W↑    */
a_(0, "Alt+Shift+S", 0x2193)   a_(0, "Alt+Shift+D", 0x2192) /* A← S↓ D→ */
#ifndef Q_OS_MAC
                                  a_(0, "Alt+Shift+#", 0x2039) /* ‹ (3) */
                                  a_(0, "Alt+Shift+$", 0x203A) /* › (4) */
a_(0, "Alt+6",  0x00A7) /* § */   a_(0, "Alt+Shift+&", 0x2021) /* ‡ (7) */
a_(0, "Alt+8",  0x2022) /* • */   a_(0, "Alt+Shift+*", 0x00B0) /* ° (8) */
                                  a_(0, "Alt+Shift+(", 0x00B7) /* · (9) */
a_(0, "Alt+-",  0x2013) /* – */   a_(0, "Alt+Shift++", 0x00B1) /* ±     */
a_(0, "Alt+R",  0x00AE) /* ® */
a_(0, "Alt+T",  0x2020) /* † */
a_(0, "Alt+O",  0x00F8) /* ø */
a_(0, "Alt+[",  0x201C) /* “ */   a_(0, "Alt+Shift+{", 0x201D) /* ” */
a_(0, "Alt+]",  0x2018) /* ‘ */   a_(0, "Alt+Shift+}", 0x2019) /* ’ */
a_(0, "Alt+\\", 0x00AB) /* « */   a_(0, "Alt+Shift+|", 0x00BB) /* » */
a_(0, "Alt+F",  0x0192) /* ƒ */
a_(0, "Alt+G",  0x00A9) /* © */
a_(0, "Alt+J",  0x2206) /* ∆ */
a_(0, "Alt+;",  0x2026) /* … */
a_(0, "Alt+V",  0x221A) /* √ */   a_(0, "Alt+Shift+V", 0x25CA) /* ◊ */
a_(0, "Alt+M",  0x00B5) /* µ */
a_(0, "Alt+,",  0x2264) /* ≤ */
a_(0, "Alt+.",  0x2265) /* ≥ */
a_(0, "Alt+/",  0x00F7) /* ÷ */   a_(0, "Alt+Shift+?", 0x00BF) /* ¿ */
#endif
/*
ʁLINE DRAWING.ʀ The following commands replace current character with appropriate
Unicode character from the Box Drawing section (U+2500 to U+257F) that connects
to neighbours making a line, moving cursor in given direction. Character at new
position is not updated, so retracking may be required to properly draw closing
corner. Both single and double lines are supported, with all their combinations
that are available in Unicode:      ┌──┐  ┌─┬┐  ╒═╤╕  ╓─╥╖  ╔══╗  ╔═╦╗
                                    │  │  ├─┼┤  ╞═╪╡  ╟─╫╢  ║  ║  ╠═╬╣
                                    └──┘  └─┴┘  ╘═╧╛  ╙─╨╜  ╚══╝  ╚═╩╝
 Super+{arrows} - move cursor in given direction drawing a line fragment

 Super+'-' (alias Ctrl+'-') - toggle single line mode └─┴┐┌┬┘
 Super+'=' (alias Ctrl+'=') - toggle double line mode ╚═╩╗╔╦╝

When either line mode is active, inserting lines or empty columns automatically
connects the gaps by adding vertical or horizontal line (with appropriate type)
*/
k_(TE_LDMOD1,   "Super+-",  0xcf1e1) /* включить/выкл режим: одиночных линий */
k_(TE_LDMOD2,   "Super+=",  0xcf1e2) /*                       двойных линий  */
k_(TE_LD1LT, "Super+Left",  0xcf112) /* курсор влево  ┐                      */
k_(TE_LD1UP, "Super+Up",    0xcf113) /*        вверх  │ нарисовав фрагмент   */
k_(TE_LD1RT, "Super+Right", 0xcf114) /*        вправо │ линии в тек. позиции */
k_(TE_LD1DN, "Super+Down",  0xcf115) /*        вниз   ┘                      */
a_(TE_LD1LT, "Ctrl+Alt+H",  0xcf112) /*                          ┌────┐      */
a_(TE_LD1UP, "Ctrl+Alt+U",  0xcf113) /* aliases without Super:   │ U↑ │      */
a_(TE_LD1RT, "Ctrl+Alt+K",  0xcf114) /*                     ┌────┼────┼────┐ */
a_(TE_LD1DN, "Ctrl+Alt+J",  0xcf115) /*                     │ ←H │ J↓ │ K→ │ */
a_(TE_LDMOD1,"Ctrl+-",      0xcf1e1) /* toggle single mode  └────┴────┴────┘ */
a_(TE_LDMOD2,"Ctrl+=",      0xcf1e2) /* ═ double line mode                   */
/*---------------------------------------------------------------------------*/
k_(TK_ZERO,0,0)
k_END_OF_TABLE
